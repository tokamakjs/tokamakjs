"use strict";(self.webpackChunktokamak_docs=self.webpackChunktokamak_docs||[]).push([[902],{2846:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return d},default:function(){return c}});var o=n(7462),r=n(3366),a=(n(7294),n(3905)),i={sidebar_position:2},s="Routing and Routes",l={unversionedId:"getting-started/routing",id:"getting-started/routing",isDocsHomePage:!1,title:"Routing and Routes",description:"A route in TokamakJS is comprised of a view and a controller. Each view in TokamakJS is 1:1 mapped to a controller meaning that each controller can only be used in their corresponding view and viceversa.",source:"@site/docs/getting-started/routing.md",sourceDirName:"getting-started",slug:"/getting-started/routing",permalink:"/tokamakjs/docs/getting-started/routing",editUrl:"https://github.com/tokamakjs/tokamak-docs/edit/master/docs/getting-started/routing.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Project",permalink:"/tokamakjs/docs/getting-started/project"},next:{title:"Providers",permalink:"/tokamakjs/docs/getting-started/providers"}},d=[{value:"Controllers",id:"controllers",children:[]},{value:"Using data",id:"using-data",children:[]},{value:"Reacting to the life-cycle",id:"reacting-to-the-life-cycle",children:[{value:"Mount and unmount step",id:"mount-and-unmount-step",children:[]},{value:"Render step",id:"render-step",children:[]}]},{value:"Tracking property values",id:"tracking-property-values",children:[]},{value:"Views",id:"views",children:[]},{value:"Using routes",id:"using-routes",children:[{value:"Nested routes",id:"nested-routes",children:[]},{value:"Routes from other sub-apps",id:"routes-from-other-sub-apps",children:[]}]}],p={toc:d};function c(e){var t=e.components,n=(0,r.Z)(e,["components"]);return(0,a.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"routing-and-routes"},"Routing and Routes"),(0,a.kt)("p",null,"A route in ",(0,a.kt)("strong",{parentName:"p"},"TokamakJS")," is comprised of a ",(0,a.kt)("strong",{parentName:"p"},"view")," and a ",(0,a.kt)("strong",{parentName:"p"},"controller"),". Each view in ",(0,a.kt)("strong",{parentName:"p"},"TokamakJS")," is 1:1 mapped to a controller meaning that each controller can only be used in their corresponding view and viceversa."),(0,a.kt)("p",null,"Finally, each route will have an associated path that will map the controller to the corresponding browser url."),(0,a.kt)("h2",{id:"controllers"},"Controllers"),(0,a.kt)("p",null,"Controllers are the main link between the view layer and the rest of the application. For that, they sit in a blurry line between what is considered application/business logic and what is considered view logic."),(0,a.kt)("p",null,"They take care of providing their views with the required data, perform any required initialization steps and react to events triggered by the view. Everything that is not strictly view logic, goes in a controller."),(0,a.kt)("p",null,"To create a controller, decorate a class with the ",(0,a.kt)("inlineCode",{parentName:"p"},"@Controller")," decorator. E.g."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Controller } from '@tokamakjs/react';\n\nimport { CounterView } from './counter.view';\n\n@Controller({ view: CounterView })\nclass CounterController {}\n")),(0,a.kt)("h2",{id:"using-data"},"Using data"),(0,a.kt)("p",null,"You can store and manipulate data inside controllers by using the ",(0,a.kt)("inlineCode",{parentName:"p"},"@state")," decorator."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Controller, state } from '@tokamakjs/react';\n\nimport { CounterView } from './counter.view';\n\n@Controller({ view: CounterView })\nclass CounterController {\n  @state private _counter = 0;\n\n  public increase(): void {\n    this._counter += 1;\n  }\n\n  public decrease(): void {\n    this._counter -= 1;\n  }\n}\n")),(0,a.kt)("p",null,"Any change to a property decorated this way will trigger a re-render of the associated view. It's very similar to the ",(0,a.kt)("inlineCode",{parentName:"p"},"useState()")," hook in React."),(0,a.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"You should treat the data stored using ",(0,a.kt)("inlineCode",{parentName:"p"},"@state")," as immutable. ",(0,a.kt)("strong",{parentName:"p"},"TokamakJS")," will only react to new assignments to properties tracked this way and any change made to the stored data itself (for example, mutating an object's property) will not trigger a re-render of the view."))),(0,a.kt)("p",null,"Additionally, in case you want to store data between re-renders but don't want to re-render the view every time the data is modified, a ",(0,a.kt)("inlineCode",{parentName:"p"},"@ref")," decorator similar to the ",(0,a.kt)("inlineCode",{parentName:"p"},"useRef()")," hook from React is provided. E.g."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Controller, ref } from '@tokamakjs/react';\n\nimport { CounterView } from './counter.view';\n\n@Controller({ view: CounterView })\nclass CounterController {\n  @ref private _counter = 0;\n\n  get counter() {\n    return this._counter;\n  }\n\n  public increase(): void {\n    // this will not trigger a re-render as the property is decorated with @ref\n    this._counter += 1;\n  }\n}\n")),(0,a.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"Any property not decorated with either ",(0,a.kt)("inlineCode",{parentName:"p"},"@state")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"@ref")," will have their values re-initialized every time the view re-renders."))),(0,a.kt)("h2",{id:"reacting-to-the-life-cycle"},"Reacting to the life-cycle"),(0,a.kt)("h3",{id:"mount-and-unmount-step"},"Mount and unmount step"),(0,a.kt)("p",null,"In case certain methods need to run when first mounting the view, an ",(0,a.kt)("inlineCode",{parentName:"p"},"onDidMount()")," decorator is available. This decorator, very similar to the ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect()")," hook from React when using an empty array as dependencies, will make any decorated method run when the view is rendered for the first time."),(0,a.kt)("p",null,"Similarly to the mentioned ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect()")," hook, methods decorated with ",(0,a.kt)("inlineCode",{parentName:"p"},"onDidMount()")," can return a callback function that will run when the component is unmounted."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Controller, onDidMount } from '@tokamakjs/react';\n\nimport { CounterView } from './counter.view';\n\n@Controller({ view: CounterView })\nclass CounterController {\n\n  @onDidMount()\n  protected didMount(): void {\n    // this will run when the view is rendered for the first time\n  }\n\n  @onDidMount()\n  protected anotherDidMount(): Function {\n    // this will also run when the view is rendered for the first time\n\n    return () => {\n      // this runs when the component is going to be unmounted\n    };\n  }\n\n}\n")),(0,a.kt)("h3",{id:"render-step"},"Render step"),(0,a.kt)("p",null,"Very similar to ",(0,a.kt)("inlineCode",{parentName:"p"},"onDidMount()")," we have the ",(0,a.kt)("inlineCode",{parentName:"p"},"onDidRender()")," decorator to run a method every time the view is re-rendered. This decorator also supports returning a void function to be run before the view is re-rendered."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Controller, onDidRender } from '@tokamakjs/react';\n\nimport { CounterView } from './counter.view';\n\n@Controller({ view: CounterView })\nclass CounterController {\n\n  @onDidRender()\n  protected didMount(): void {\n    // this will run every time the view is re-rendered\n  }\n\n  @onDidRender()\n  protected anotherDidMount(): Function {\n    // this will also run every time the view is re-rendered\n\n    return () => {\n      // this will run every time before the view is re-rendered\n    };\n  }\n\n}\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"onDidRender()")," decorator can be compared to using the ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect()")," hook without providing an array of dependencies."),(0,a.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"An execution order is not guaranteed when having multiple methods decorated with the life-cycle decorators so don't make any assumptions based on it."))),(0,a.kt)("h2",{id:"tracking-property-values"},"Tracking property values"),(0,a.kt)("p",null,"It's possible to track changes to properties using the ",(0,a.kt)("inlineCode",{parentName:"p"},"@effect()")," decorator. It takes a single argument that is the current instance of the class and should return an array with a set of values to track between re-renders."),(0,a.kt)("p",null,"The behavior is the same as before, any method decorated with this decorator will run when the any of the tracked values change. It also supports returning a void callback to perform any teardown between re-renders."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Controller, effect } from '@tokamakjs/react';\n\nimport { CounterView } from './counter.view';\n\n@Controller({ view: CounterView })\nclass CounterController {\n  @state private _trackedCounter = 0;\n  @state private _counter = 0;\n\n  @effect((self: CounterController) => [self._trackedCounter])\n  protected reactToTrackedCounter(): void {\n    // this will run every time _trackedCounter changes. However, any\n    // changes to _counter will not have any effects.\n  }\n}\n")),(0,a.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"Decorators ",(0,a.kt)("inlineCode",{parentName:"p"},"onDidMount()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"onDidRender()")," are just useful abstractions over simply using the effect decorator with an empty array as dependencies, ",(0,a.kt)("inlineCode",{parentName:"p"},"@effect(() => [])")," or with no dependencies ",(0,a.kt)("inlineCode",{parentName:"p"},"@effect()")," respectively."))),(0,a.kt)("h2",{id:"views"},"Views"),(0,a.kt)("p",null,"Views are just regular React components that have a specific controller associated to them. Together with this controller, they compose a route in ",(0,a.kt)("strong",{parentName:"p"},"TokamakJS"),"."),(0,a.kt)("p",null,"We can access the associated controller by using the provided ",(0,a.kt)("inlineCode",{parentName:"p"},"useController()")," hook."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { useController } from '@tokamakjs/react';\n\nimport { CounterController } from './counter.controller';\n\n// As we can see, a view is just a regular React function component\nexport const CounterView = () => {\n  const ctrl = useController<CounterController>();\n\n  return (\n    <div>\n      <span>value: {ctrl.counter}</span> // we can read values from the controller\n      <button onClick={() => ctrl.increase()}>Increase</button> // or we can call methods\n    </div>\n  )\n};\n")),(0,a.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),(0,a.kt)("strong",{parentName:"h5"},"Views are 100% compatible with existing React hooks"))),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"Even though nothing prevents you from doing so, try to put the least amount of business logic in the views. The views should only contain basic view logic like: ",(0,a.kt)("em",{parentName:"p"},"Is the modal visible? is this component toggled on or off? etc.")," That way, we can change the look of the application in the future without having to change the rest of the business logic."))),(0,a.kt)("h2",{id:"using-routes"},"Using routes"),(0,a.kt)("p",null,"After we've created our controller and our view, we have to tell ",(0,a.kt)("strong",{parentName:"p"},"TokamakJS")," about them. Controllers always belong to a ",(0,a.kt)("em",{parentName:"p"},"SubApp")," since they're directly involved in the routing of the application. To add a controller to a ",(0,a.kt)("strong",{parentName:"p"},"TokamakJS")," sub-app simply use the provided ",(0,a.kt)("inlineCode",{parentName:"p"},"createRoute()")," helper and add the resulting route to the ",(0,a.kt)("inlineCode",{parentName:"p"},"routing")," array in the corresponding ",(0,a.kt)("inlineCode",{parentName:"p"},"@SubApp()")," decorator."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { SubApp, createRoute } from '@tokmamakjs/react';\n\nimport { CounterController } from './routes/counter';\n\n@SubApp({\n  routing: [createRoute('/', CounterController)],\n})\nexport class AppModule {}\n")),(0,a.kt)("h3",{id:"nested-routes"},"Nested routes"),(0,a.kt)("p",null,"It's also possible to nest routes in ",(0,a.kt)("strong",{parentName:"p"},"TokamakJS"),". The children routes will have the parent route path appended to them as basepath."),(0,a.kt)("p",null,"First, add children routes to the parent route:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { SubApp, createRoute } from '@tokmamakjs/react';\n\nimport { ParentController } from './routes/parent';\nimport { ChildController } from './routes/child';\n\n@SubApp({\n  routing: [createRoute('/', ParentController, [\n    createRoute('/child', ChildController),\n  ])],\n})\nexport class AppModule {}\n")),(0,a.kt)("p",null,"And then, use the ",(0,a.kt)("inlineCode",{parentName:"p"},"<Outlet />")," component in the parent view to render the child when needed:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Outlet } from '@tokamakjs/react';\n\nimport { Header, Container } from '../components';\n\nexport const ParentView = () => {\n  return <Container>\n    <Header />\n    <Outlet /> {/* <- ChildView will be rendered here when path equals '/child' */}\n  </Container>\n};\n")),(0,a.kt)("h3",{id:"routes-from-other-sub-apps"},"Routes from other sub-apps"),(0,a.kt)("p",null,"Finally, it's also possible to include routes from other subapps when composing multiple of them together. Use the provided ",(0,a.kt)("inlineCode",{parentName:"p"},"includeRoutes()")," function to do so. E.g."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { SubApp, createRoute, includeRoutes } from '@tokamakjs/react';\n\nimport { FooModule } from './modules/foo';\nimport { BarModule } from './modules/bar';\n\n@SubApp({\n  routing: [\n    // Every route inside FooModule will be prefixed with `/foo`\n    includeRoutes('/foo', FooModule),\n    // Every route inside BarModule will be prefixed with `/bar`\n    includeRoutes('/bar', BarModule),\n  ],\n})\nexport class AppModule {}\n")))}c.isMDXComponent=!0}}]);